"use strict";(self.webpackChunkvyckey_computer_notes=self.webpackChunkvyckey_computer_notes||[]).push([[5045],{82051:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=t(74848),o=t(28453);const a={title:"Jackson Polymorphic",tags:["java","json","jackson"],sidebar_label:"Polymorphic",sidebar_position:5},s=void 0,i={id:"library/jackson/polymorphic",title:"Jackson Polymorphic",description:"\u81ea\u5b9a\u4e49\u5c5e\u6027\u591a\u6001\u53cd\u5e8f\u5217\u5316",source:"@site/java/library/jackson/polymorphic.md",sourceDirName:"library/jackson",slug:"/library/jackson/polymorphic",permalink:"/java/library/jackson/polymorphic",draft:!1,unlisted:!1,tags:[{label:"java",permalink:"/java/tags/java"},{label:"json",permalink:"/java/tags/json"},{label:"jackson",permalink:"/java/tags/jackson"}],version:"current",lastUpdatedBy:"vyckey",lastUpdatedAt:174745298e4,sidebarPosition:5,frontMatter:{title:"Jackson Polymorphic",tags:["java","json","jackson"],sidebar_label:"Polymorphic",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Advanced Features",permalink:"/java/library/jackson/jackson_advance"},next:{title:"Framework Introduction",permalink:"/java/library/jackson/framework"}},l={},c=[];function p(e){const n={code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"\u81ea\u5b9a\u4e49\u5c5e\u6027\u591a\u6001\u53cd\u5e8f\u5217\u5316"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.ObjectCodec;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.common.collect.Maps;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Optional;\n\npublic class PropertyPolymorphicDeserializer<T> extends StdDeserializer<T> {\n    /**\n     * the registry of unique type id to class types\n     */\n    private final Map<String, Class<? extends T>> registry = Maps.newHashMap();\n    private final String property;\n\n    public PropertyPolymorphicDeserializer(Class<T> superClass, String property) {\n        super(superClass);\n        this.property = property;\n    }\n\n    public void register(String typeId, Class<? extends T> typeClass) {\n        registry.put(typeId, typeClass);\n    }\n\n    protected String resolveTypeId(JsonNode jsonNode) {\n        return Optional.ofNullable(property).map(jsonNode::get).map(JsonNode::textValue).orElse(null);\n    }\n\n    @Override\n    public T deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n        ObjectCodec codec = jsonParser.getCodec();\n        ObjectNode jsonNode = codec.readTree(jsonParser);\n\n        String typeId = resolveTypeId(jsonNode);\n        if (typeId == null) {\n            context.reportBadDefinition(handledType(), "No type id for class \\"" + handledType() + "\\" deserialization");\n        }\n        Class<? extends T> subtypeClass = registry.get(typeId);\n        if (subtypeClass == null) {\n            context.reportBadDefinition(handledType(), "No corresponding \\"" + handledType() + "\\" subtype class found for type id" + typeId);\n        }\n\n        return codec.treeToValue(jsonNode, subtypeClass);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"\u5d4c\u5957\u591a\u5c42\u7ea7\u591a\u6001\u53cd\u5e8f\u5217\u5316"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.ObjectCodec;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class NestedPolymorphicDeserializer extends StdDeserializer<Object> {\n    public NestedPolymorphicDeserializer(Class<?> vc) {\n        super(vc);\n    }\n\n    public NestedPolymorphicDeserializer(JavaType valueType) {\n        super(valueType);\n    }\n\n    /**\n     * navigates through the given class hierarchy to find the concrete implementation based\n     * in the provided discriminator properties defined in the class\n     */\n    protected Class<?> resolveConcreteType(Class<?> last, Class<?> current, Function<String, String> fieldValueExtractor) {\n        JsonTypeInfo currentTypeInfo = current.getAnnotation(JsonTypeInfo.class);\n        if (currentTypeInfo == null) {\n            return current;\n        }\n\n        if (current.equals(last)) {\n            return current;\n        }\n\n        JsonSubTypes subTypes = current.getAnnotation(JsonSubTypes.class);\n        Map<String, Class<?>> subTypesByDiscriminatorValue = Stream.of(subTypes.value())\n                .collect(Collectors.toMap(JsonSubTypes.Type::name, JsonSubTypes.Type::value));\n\n        // gets the JSON property to use as the discriminator\n        String subTypeDiscriminatorProperty = currentTypeInfo.property();\n\n        // gets the discriminator value using the JSON property obtained above\n        String discriminatorValue = fieldValueExtractor.apply(subTypeDiscriminatorProperty);\n\n        // finally, through the map created above, it gets the class mapped to the discriminator value.\n        Class<?> subType = subTypesByDiscriminatorValue.get(discriminatorValue);\n\n        // recursively calls the method with the subType found and the JSON field value extractor.\n        return this.resolveConcreteType(current, subType, fieldValueExtractor);\n    }\n\n    @Override\n    public Object deserialize(final JsonParser jsonParser, final DeserializationContext context) throws IOException {\n        // gets the json node being deserialized\n        ObjectCodec oc = jsonParser.getCodec();\n        JsonNode node = oc.readTree(jsonParser);\n\n        // gets the type of the node being serialized\n        Class<?> deserializingType = handledType() != null ? handledType() : getValueType().getRawClass();\n\n        // resolve the concrete type based in the node being serialized and the super type of the field\n        Class<?> concreteType = this.resolveConcreteType(null, deserializingType, fieldName -> {\n            JsonNode jsonNode = node.get(fieldName);\n            return jsonNode.asText();\n        });\n\n        // traverses the node to get the node parser and finally, reads the node providing the concrete class that must be created\n        JsonParser parserOfNode = node.traverse(oc);\n\n        return parserOfNode.readValueAs(concreteType);\n    }\n    \n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(96540);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);